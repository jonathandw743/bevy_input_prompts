// pub mod product_ids;
// pub mod vendor_ids;

// fn copy_assets<I: IntoIterator<Item = P>, P: AsRef<Path>>(asset_dirs: I) {
//     let addon_asset_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("assets");
//     let asset_paths = asset_dirs
//         .into_iter()
//         .map(|dir| addon_asset_dir.join(dir))
//         .collect::<Vec<_>>();
//     let this_asset_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap()).join("assets");
//     fs::create_dir_all(&this_asset_dir).expect("creating asset directory failed");
//     fs_extra::copy_items(
//         &asset_paths,
//         this_asset_dir,
//         &CopyOptions {
//             overwrite: false,
//             skip_exist: true,
//             content_only: false,
//             depth: 0,
//             ..Default::default()
//         },
//     )
//     .expect("copying assets failed");
// }

// /// copy assets into the assets directory for just using basic, autogenerated input prompts
// pub fn build_basic() {
//     copy_assets([directory_representation::bevy_input_prompts::not_found]);
// }

// /// copy assets into the assets directory for just using Xelu's input prompts
// pub fn build_xelu() {
//     copy_assets([
//         directory_representation::bevy_input_prompts::not_found,
//         directory_representation::bevy_input_prompts::xelu,
//     ]);
// }

// /// copy assets into the assets directory for just using Kenney's input prompts
// pub fn build_kenney() {
//     copy_assets([
//         directory_representation::bevy_input_prompts::not_found,
//         directory_representation::bevy_input_prompts::kenney,
//     ]);
// }

// /// copy assets into the assets directory for just using any input prompts
// pub fn build_all() {
//     copy_assets([
//         directory_representation::bevy_input_prompts::not_found,
//         directory_representation::bevy_input_prompts::xelu,
//         directory_representation::bevy_input_prompts::kenney,
//     ]);
// }

pub mod directory_representation {
    // bevy_input_prompts_macros::directory_representation!("assets/bevy_input_prompts/not_found/MouseButton");
    // bevy_input_prompts_macros::directory_representation!("assets/test");
    // bevy_input_prompts_macros::directory_representation!("assets/bevy_input_prompts");
    // bevy_input_prompts_macros::directory_representation!("assets/bevy_input_prompts/kenney/kenney_input-prompts/Xbox Series/Default");
    // bevy_input_prompts_macros::directory_representation!("assets/bevy_input_prompts/xelu/Xelu_Free_Controller&Key_Prompts/Xbox Series");
    // bevy_input_prompts_macros::directory_representation!("assets/bevy_input_prompts/kenney/kenney_input-prompts");
    // bevy_input_prompts_macros::directory_representation!("assets/bevy_input_prompts/kenney/kenney_input-prompts/Flairs/Default");
    bevy_input_prompts_macros::directory_representation!(
        "assets/bevy_input_prompts/kenney/kenney_input-prompts/Keyboard & Mouse/Default"
    );
    // bevy_input_prompts_macros::directory_representation!("assets/test");
}

/// Assumes each slice is sorted
/// slower for debug builds
pub fn file_index_safe(tokens_associated_files: &[&[usize]]) -> usize {
    let mut i = 0;
    while i < tokens_associated_files.len() && tokens_associated_files[i].is_empty() {
        i += 1;
    }
    if i >= tokens_associated_files.len() {
        return 0;
    }
    let mut possible_files = Vec::from(tokens_associated_files[i]);
    for k in 1..tokens_associated_files.len() {
        let mut new_possible_files = Vec::with_capacity(possible_files.len());
        let mut i = 0;
        let mut j = 0;
        while i < possible_files.len() && j < tokens_associated_files[k].len() {
            if possible_files[i] == tokens_associated_files[k][j] {
                new_possible_files.push(possible_files[i]);
                i += 1;
                j += 1;
            } else if possible_files[i] < tokens_associated_files[k][j] {
                i += 1;
            } else if possible_files[i] > tokens_associated_files[k][j] {
                j += 1;
            }
        }
        if !new_possible_files.is_empty() {
            possible_files = new_possible_files;
        }
    }
    possible_files[0]
}

pub fn file_index(tokens_associated_files: &[&[usize]]) -> usize {
    let mut i = 0;
    while i < tokens_associated_files.len()
        && unsafe { *tokens_associated_files.as_ptr().add(i) }.is_empty()
    {
        i += 1;
    }
    if i >= tokens_associated_files.len() {
        return 0;
    }
    let mut possible_files = Vec::from(unsafe { *tokens_associated_files.as_ptr().add(i) });
    for k in 1..tokens_associated_files.len() {
        let mut new_possible_files = Vec::with_capacity(possible_files.len());
        let mut i = 0;
        let mut j = 0;
        while i < possible_files.len()
            && j < unsafe { *tokens_associated_files.as_ptr().add(k) }.len()
        {
            if unsafe { *possible_files.as_ptr().add(i) }
                == unsafe { *(*tokens_associated_files.as_ptr().add(k)).as_ptr().add(j) }
            {
                new_possible_files.push(unsafe { *possible_files.as_ptr().add(i) });
                i += 1;
                j += 1;
            } else if unsafe { *possible_files.as_ptr().add(i) }
                < unsafe { *(*tokens_associated_files.as_ptr().add(k)).as_ptr().add(j) }
            {
                i += 1;
            } else if unsafe { *possible_files.as_ptr().add(i) }
                > unsafe { *(*tokens_associated_files.as_ptr().add(k)).as_ptr().add(j) }
            {
                j += 1;
            }
        }
        if !new_possible_files.is_empty() {
            possible_files = new_possible_files;
        }
    }
    possible_files[0]
}
